/*
* This project and associated original files are licensed under the GPLv3 License Copyright (c) 2024 Sam Groveman 
* Contributors: Sam Groveman
*/

#include <Arduino.h>
#include <esp_wifi.h>
#include <Wire.h>
#include <Webserver.h>
#include <ESPAsyncWebServer.h>
#include <ESPAsyncWiFiManager.h>
#include <Storage.h>
#include <Configuration.h>
#include <EventBroadcaster.h>
#include <ActorManager.h>
#include <WiFiConfig.h>
#include <ESPmDNS.h>
#include <SensorManager.h>
#include <PeriodicTasks.h>
#include <DeviceLoader.h>
#include <TimeInterface.h>
#include <LogBroadcaster.h>

/// @brief Current firmware version
extern const String FW_VERSION = "0.6.0";

/// @brief Set to true when the POST finishes successfully
bool POSTSuccess = false;

/// @brief AsyncWebServer object (passed to WfiFiConfig and WebServer)
AsyncWebServer server(80);

/// @brief Webserver handling all requests
Webserver webserver(&server);

/// @brief Loads all actor, sensor, and event receiver devices
DeviceLoader loader;

/// @brief Handle to track periodic task loop
TaskHandle_t periodicHandle = NULL;

/// @brief The number of ms that have passed when the loop is run
volatile ulong current_millis_task = 0;

/// @brief Handle for NTP task loop
TaskHandle_t ntpTaskHandle = NULL;

/// @brief  The number of ms that have passed when the loop is run
volatile ulong current_millis_ntp = 0;

/// @brief Handles disconnection from WiFi (adapted from https://randomnerdtutorials.com/esp32-useful-wi-fi-functions-arduino/#11)
/// @param event The event
/// @param info The info associated with the event
void WiFiDisconnected(WiFiEvent_t event, WiFiEventInfo_t info) {
	EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
	Logger.print("WiFi lost connection. Reason: ");
	Logger.println(info.wifi_sta_disconnected.reason);
	Logger.println("Trying to Reconnect");
	WiFi.disconnect();
	if (WiFi.reconnect()) {
		// Stop webserver
		webserver.ServerStop();
		// Start webserver
		webserver.ServerStart();
		Logger.println("WiFi reconnected");
		EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Ready);
	}
}

/// @brief Checks for and runs periodic tasks as needed
/// @param args Not used
void periodicTaskLoop(void* args) {
	/// @brief The number of ms at which periodic tasks were last run
	ulong previous_millis_task = 0;
	
	while(Configuration::currentConfig.tasksEnabled) {
		current_millis_task = millis();
		if (current_millis_task - previous_millis_task > Configuration::currentConfig.period) {
			EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Running);
			if (!PeriodicTasks::callTasks(current_millis_task - previous_millis_task)) {
				EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
			} else {
				EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Ready);
			}
			previous_millis_task = current_millis_task;
		}
		delay(1); // Token delay to allow thread to yield (unnecessary?)
	}
	Logger.println("Periodic task loop exiting");
	periodicHandle = NULL;
	vTaskDelete(NULL);
}

/// @brief Updates time via NTP as needed
/// @param args Not used
void ntpTaskLoop(void* args) {
	/// @brief The number of ms at which NTP sync was last run
	ulong previous_millis_ntp = 0;

	while(Configuration::currentConfig.WiFiClient && Configuration::currentConfig.useNTP) {
		current_millis_ntp = millis();
		// Synchronize the time at regular interval
		if (current_millis_ntp - previous_millis_ntp > Configuration::currentConfig.ntpUpdatePeriod) {
			Logger.println("Setting time by NTP");
			configTime(Configuration::currentConfig.gmtOffset_sec, Configuration::currentConfig.daylightOffset_sec, Configuration::currentConfig.ntpServer1.c_str(), Configuration::currentConfig.ntpServer2.c_str(), Configuration::currentConfig.ntpServer3.c_str());
			previous_millis_ntp = current_millis_ntp;
		}
		// NTP will never sync more frequently than this, so a long delay is reasonable here
		delay(30000);
	}
	Logger.println("NTP sync loop exiting");
	ntpTaskHandle = NULL;
	vTaskDelete(NULL);
}

void setup() {
	// Load all event and log receivers
	loader.LoadReceivers();

	// Start loggers
	if (!Logger.beginReceivers()) {
		Serial.println("Could not start all log receivers");
		while(true);
	}
	// Let any serial monitors connect
	delay(1000);
	Logger.print("Booting ESP32 device hub V");
	Logger.println(FW_VERSION);
	Logger.println();
	Logger.println("Designed and created by Sam Groveman (C) 2024");
	Logger.println();

	// Start event receivers
	if (!EventBroadcaster::beginReceivers()) {
		Logger.println("Could not start all event receivers");
		while(true);
	}

	// Broadcast startup event
	EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Starting);

	// Start storage
	if (!Storage::begin()) {
		EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
		Logger.println("Could not start storage");
		while(true);
	}

	// Start configuration manager
	if (!Configuration::begin()) {
		EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
		Logger.println("Could not start configuration manager");
		while(true);
	}

	// Set hostname
	WiFi.setHostname(Configuration::currentConfig.hostname.c_str());

	// Pre-configure WiFi
	WiFi.mode(WIFI_STA);
 	esp_wifi_set_ps(WIFI_PS_NONE);
	
	if (Configuration::currentConfig.WiFiClient) {
		// Configure WiFi client
		DNSServer dns;
		AsyncWiFiManager manager(&server, &dns);
		WiFiConfig configurator(&manager, Configuration::currentConfig.configSSID, Configuration::currentConfig.configPW);
		configurator.connectWiFi();
		WiFi.setAutoReconnect(true);
		server.reset();
		server.end();
		// Attach handler for WiFi disconnected
		WiFi.onEvent(WiFiDisconnected, WiFiEvent_t::ARDUINO_EVENT_WIFI_STA_DISCONNECTED);
	} else {
		// Start AP
		WiFi.softAP(Configuration::currentConfig.configSSID, Configuration::currentConfig.configPW);
	}

	// Clear server settings, just in case
	webserver.ServerStop();

	// Start the webserver
	webserver.ServerStart();
	xTaskCreate(Webserver::RebootCheckerTaskWrapper, "Reboot Checker Loop", 1024, &webserver, 1, NULL);

	// Start MDNS service
	if (Configuration::currentConfig.mdns) {
		if(!MDNS.begin(Configuration::currentConfig.hostname)) {
			Logger.println("Could not start MDNS service");
			EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
			while(true);
		}
	}

	// Set time via NTP if needed
	if (Configuration::currentConfig.WiFiClient && Configuration::currentConfig.useNTP) {
		configTime(Configuration::currentConfig.gmtOffset_sec, Configuration::currentConfig.daylightOffset_sec, Configuration::currentConfig.ntpServer1.c_str(), Configuration::currentConfig.ntpServer2.c_str(), Configuration::currentConfig.ntpServer3.c_str());
	}

	// Start periodic task controller
	if (!PeriodicTasks::begin()) {
		Logger.println("Could not start periodic task controller");
		EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
		while(true);
	}	

	// Load all devices
	loader.LoadDevices();

	// Start sensors
	if (!SensorManager::beginSensors()) {
		EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
		while(true);
	}

	// Start actors
	if (!ActorManager::beginActors()) {
		EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
		while(true);
	}

	// Print the configured sensors, actors, and webhooks
	Logger.println(SensorManager::getSensorInfo());
	Logger.println(ActorManager::getActorInfo());

	// Start action processor loop, the stack depth has been significantly over-provisioned for the action loop as there's no way to know what actions could be running
	xTaskCreate(ActorManager::actionProcessor, "Action Processor Loop", getArduinoLoopTaskStackSize() * 2, NULL, 1, NULL);

	// Give info to user
	Logger.println("Time: " + TimeInterface::getDateTime());
	Logger.print("IP Address: ");
	Logger.println(WiFi.localIP().toString());

	// Ready!
	POSTSuccess = true;
	EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Ready);
	Logger.println("System ready!");
}

/// @brief The number of ms that have passed when the loop is run
ulong current_millis = 0;

void loop() {
	current_millis = millis();
	// Manage NTP sync loop
	if(Configuration::currentConfig.WiFiClient && Configuration::currentConfig.useNTP) {
		if (ntpTaskHandle == NULL) {
			current_millis_ntp = current_millis;
			if(xTaskCreate(ntpTaskLoop, "NTP Sync", 2048, NULL, 1, &ntpTaskHandle) != pdPASS) {
				Logger.println("Could not create NTP sync task");
				EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
			}
		} else if (eTaskGetState(ntpTaskHandle) == eDeleted) {		
			Logger.println("NTP sync loop did not exit cleanly, fixing...");
			EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
			ntpTaskHandle = NULL;
		} else {
			// Check to see if NTP sync task loop is locked up
			if (current_millis > current_millis_ntp && current_millis - current_millis_ntp > (Configuration::currentConfig.ntpUpdatePeriod * 2)) {
				Logger.println("NTP sync loop has not run in more than two sync periods, fixing...");
				EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
				vTaskDelete(ntpTaskHandle);
				ntpTaskHandle = NULL;
			}
		}
	}
	// Manage periodic task loop
	if (Configuration::currentConfig.tasksEnabled) {
		if (periodicHandle == NULL) {
			// Periodic tasks run in their own loop so that if it crashes it can be restarted
			current_millis_task = current_millis;
			// The stack depth has been significantly over-provisioned for the task loop as there's no way to know what tasks could be running
			if(xTaskCreate(periodicTaskLoop, "Periodic Tasks", getArduinoLoopTaskStackSize() * 2, NULL, 1, &periodicHandle) != pdPASS) {
				Logger.println("Could not create periodic task loop");
				EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
			}
		} else if (eTaskGetState(periodicHandle) == eDeleted) {		
			Logger.println("Periodic task loop did not exit cleanly, fixing...");
			EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
			periodicHandle = NULL;
		} else {
			// Check to see if periodic task loop is locked up
			if (current_millis > current_millis_task && current_millis - current_millis_task > (Configuration::currentConfig.period * 3)) {
				Logger.println("Periodic task loop has not run in more than three task periods, fixing...");
				EventBroadcaster::broadcastEvent(EventBroadcaster::Events::Error);
				vTaskDelete(periodicHandle);
				periodicHandle = NULL;
			}
		}
	}
	delay(100); // This loop doesn't run time critical tasks
}